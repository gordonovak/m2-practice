

-- Comments in M2 are preceded by two dashes
-- An important feature of M2 is the initial creation of a ring
-- Before you can work with variables you need to input a ring
-- Let's look at the ring of polynomials with rational coefficients
-- M2 can factor polynomials

R = QQ[x,y,z]
f = x^3 - y^3
factor f

-- Complex coefficients are not supported by M2
-- To factor f into linear factors, we can change the coefficient ring
-- We need to re-define f or M2 will remember it as an element of R
-- The command "describe" reminds you what the ring is
-- The command "use" allows you to switch back to the ring R
-- To think about coefficients as elements in the ring we use "_R"

C = ZZ/3[x,y,z]
ring f
f = x^3 - y^3
factor f
describe C
use R
1
1_R

-- A ring is a structure closed under addition and multiplication
-- But not all elements have multiplicative inverses!
-- A field is a ring where all non-zero elements have multiplicative inverses
-- Here QQ, the rational numbers, is a field, but QQ[x,y,z] is just a ring
-- The notation R=QQ[x,y,z] says that the polynomial ring is an algebra over QQ
-- R as an algebra is generated by {x,y,z} and R contatins all QQ-linear combinations
-- of powers of {x,y,z}
-- Let's check that a few elements are in R

x^2
x+y
x+y^2 + 100*z^3

-- You will see that the second line of the ouput says "R"
-- This means that the output is interpreseted as an element of R

x^(-1)

-- On the other hand x does not have a multiplicative inverse in R
-- So the x^(-1) is not defined in R
-- We can add an x^(-1) to R using a quotient ring
-- We add a "dummy" variable t and add the relation tx-1=0 or t=1/x
-- Notice that we need a * for multiplication in M2

S= QQ[x,y,z,t]/(t*x-1)
x^(-1)

-- After we defined S, M2 interprets all computations in S
-- The symbol "==" is used to check if two quantities are the same

y*z/x == y*z*t

describe S

use R

y*z*x 

-- The command "vars" is used to get the variables as a matrix
-- The command "entries" gives us a list of list corresponding to the rows
-- The command "flatten" removes one list level, 
-- We use "oo" to refer to the previous output
-- The command "numgens" gives you the number of generator
-- The command "coefficientRing" gives you the coefficient ring
-- Many commands in M2 have fairly intuitive names
-- Just remember the syntax "firstSecond" for capitalizing names

vars R
entries(vars R)
flatten oo
numgens R
coefficientRing R

-- To check a computation works it is usefult to use random elements
-- The command "random" gives you for a degree a random element
-- The command "basis" gives you the base of a subspace
-- The command "vars" creates a list of variables to use

random(2,R)
basis(2,R)
T1 = QQ[vars(0..25)]
vars T1
T2 = QQ[vars(26..51)]
vars T2

-- When we "added a relation" to a ring 
-- We formally create a quotient ring by modding out by an ideal
-- An ideal is an additive subspace 
-- which also contains all R-linear combinations of its elements 
-- So we can mutliply by anything in R
-- But we can only take sums of elements within the ideal
-- A linear chage of basis does not change the ideal
-- But multiplying by a non-constant term does!
-- However, we do get containments... we can check by asking "isSubset"
-- where the first argument is the subset, the second is the superset

use R
I = ideal(x,y)
J = ideal(x+2*y, x-2*y)
I == J
L = ideal(x*y, y)
I == L
I != L
isSubset(L,I)

-- We can test if an element belongs to an ideal by "reducing modulo the ideal"
-- This division makes sense only when we work with a Groebner basis for the ideal
-- But M2 does this automatically, so we will not worry about it right now
-- So to test ideal membership we use the command "%" 
-- If the division gives 0, the element is in the ideal, otherwise it is not

x % I
x % L
(y % L) == 0

-- Once we define a quotient ring (modulo an ideal)
-- We need to be careful about which ring we are in 
-- And whether the elements belong to that ring

Q = R/I
f
f = x^3 - y^3
f
use R
f = x^3 - y^3
f

-- Maps between rings are usually given as matrices
-- A word of caution: M2 inteprets the source and targets as modules
-- So R becomes R^1, "one copy of R" or a module with one direct summand = R
-- Then R^2 is a module with two direct summands = R
-- To consider the same map between summands of the quotient ring,
-- we can tensor with the quotient ring using the command "**"
-- Notice that kernels and images of maps are ways to get ideals

M = matrix{{x},{y}}
target M
source M
kernel M
image M

M1 = M**Q
kernel M1
image M1

N = matrix{{x,y}}
target N
source N
kernel N
image N
image(N) == I

-- A particularly nice class of ideals is the class of monomial ideals
-- or ideals generated by a set of monomials
-- To have a monomial ideal, we need a set of monomial generators to exist
-- but this might not be the given set!
-- Checking if a monomial belongs to a monomial ideal is easy: 
-- it needs to be a multiple of one of the monomial generators!
-- Checking if any polynomial belongs to a monomial ideal is also easy:
-- each of the monomials in the polynomial need to belong to the monomial ideal

J
I
I == J
(z*x % I )== 0
(((z+y)*x) % I )== 0
(z^2 % I )== 0
((x^2+z^2) % I )== 0
((x^2+y^2) % I )== 0










